---
layout: post
status: publish
published: true
title: За что не любят php

date: '2015-03-31 17:20:00 +0300'

categories:
- life
tags:
- php
- мысли
---
<p>
Наверняка все знакомы с такими популярными в свое время CMS как joomla, phpNuke, modx, в конце концов wordpress. Этот список можно продлить - он гораздо больше. Что общего у данных систем? Все они написаны на php, и все они имею огромное количество палагинов/тем/шаблонов как с открытым кодом так и коммерческих. Есть еще одна, характерная для данного типа систем, черта: в разрезе историй (в более младших версиях)  данные cms и общая масса сторонних плагинов:</p>
<ol>
<li>Имеют низкое качество кода. Как в целом "замес html+php+функции" - невозможно понять как это должно работать, так и полное отсутствие тестов.</li>
<li>Бесчисленное количество ошибок/багов (как уровня приложения так и уровня версии интерпретатора на которую они опираются, имеется ввиду прототипы и использование таких функций как <b>call_user_method</b>).</li>
<li>Большое сообщество разработчиков которые так или иначе используют эти системы.</li>
</ol>

<div>С другой стороны php как инструмент в ветках 4.x, 5.x (что уже говорить о более ранних), содержит в себе массу логических противоречий, несовместимостей и проблем уровня архитектуры.</div>

<p>Часть из этих проблем касается вопроса взаимодействия с другими системами. Например чего стоит магия которая возникала при работе с функцией <b>mysql_real_escape_string</b>, не стыковки c <b>safe_mode </b>и рядом других функций, часть из который на момент статьи уже либо выведена из 5.x либо считаются устаревшими (deprecated).Отдельным массивом можно выделить проблемы философии языка (так или иначе она есть у каждого я.п.). Перечислю некоторые из них:</p>
<ol>
<li><b>Возврат "ошибочного значения" вместо создания исключения, в стандартных функциях языка</b>. По этой теме было холивара, перечислено множество минусов и плюсов разных подходов. Так или иначе php представлял себя как "надстройка над perl", но те времена уже давно прошли. Со свой стороны могу сказать что подход исключений "для программиста" (скажем как в python) является более целостным и однозначным.</li>
<li><b>Скрипт php должен быть "завершен".</b> Асинхронность систем на данный момент является весомым фактором приложения. Другими словами пользователь хочет совершать действие и наблюдать результат. Как это относиться к php? Очень просто, для чтобы создать систему которая будет работать в многопользовательской среде "в фоне", а не "запускать -&gt; компилировать -&gt; выполнять" при каждом запросе скрипт нужно приложить не мало усилий. Существует множество библиотек которые работают с неблокирующем IO (non blocking io), но все же они также имеют недостатки (в сравнении с асинхронным бекэндом на node.js). Похожее ощущение проблемы можно испытать если попробовать создать демона (процесс работающий в фоне) на php.</li>
<li><b>Система обработки ошибок. </b>Как и описано выше, обработку ошибочных с помощью проверки на значение, но это пол беды. Другая часть стоит в том что доступны такие операторы как "@" которые с одной стороны предотвращают отказ в обслуживании (т.е. DOS), но с другой стороны иногда приводят к тому что ошибку невозможно отследить (записей о ней нет даже в логе). Еще одна составляющая в том что часть методов (такие как __toString) не могут выбрасывать исключения. А "fatal error" в некоторых случаях вообще невозможно отловить на уровне приложения, то есть это гарантированный отказ в обслуживании.</li>
<li><b>Уровни ошибок и магия в ядре. </b>С каждым релизом php все же приближается к "идеалу", но по моему до сих пор существует логическая неоднозначность по поводу генерируемых ошибок. Допустим в ветке php-5.3 уровень E_ALL включает в себя все ошибки кроме E_STIRICT. Так же иногда вводит заблуждение сообщения и коды об ошибках, к примеру T_PAAMAYIM_NEKUDOTAYIM возникает при некорректном использовании "::".</li>
<li><b>Традиционная урезанная модель ООП. </b>Данный подход практикуется с 4.x ветки когда появилось некоторое подобие на данную парадигму. Пространства имен, верней его отсутствие до последних версий. До php-5.5 не существовало  поддержки метода <b>finaly</b>, действия которого приходилось эмулировать. Список можно продолжить.</li>
<li><b>Встроенные функции, и их подход. </b>Всем известны функции с префиксами <b>array_* </b>(<b>str_* mb_str_* </b>и так далее), в этом и есть большой недостаток (кроме того что подход "не ооп") именование функций разниться, то они через подчеркивание, то слитно (как <b>strpos и str_rot13</b>). Существует функции которых противоречат друг другу, т.е. одни принимает ($haystack,$needle) а другие ($needle, $haystack)</li>
<li><b>Система типизации и ее недостатки.</b> Имеется ввиду проверки условия вроде "0&lt;null", наличие синонимов у int-integer bool-boolean и так далее.</li>
</ol>
<h2>И все таки, в чем плох php как инструмент?</h2>
<div>Большой массив не очень качественного кода, который впоследствии был либо взломан либо дал утечку внутренних данных, и плюс вышеперечисленные недостатки (перечислена только часть) создают впечатление что php как инструмент создает проблемы а не решает их. Потому даже у людей далеких от web-разработки, но так или иначе сталкивающихся с этим (например менеджеров в it), сложилось впечатление что "php это плохо".</div>
<div>Но все таки многие из проблем которые существуют в ранних версия (имееться ввиду 4.x, 5.3 и других) уже исправлены или доработаны. Более того многие крупные it-компании активно используют php или его подмножество-доработку (тот же HipHop VM от facebook). Написаны замечательные фреймворки (<b>symfony2</b> или <b>laravel</b>), которые с моей точки зрения, по своей архитектуре не уступают или превосходят решения на базе других платформ.</div>
<div>Другими словами, php как инструмент справляется со своей задачей, но если запросить от него то для чего он не создан, тут уж извините без гарантий.</div>
<h2>Итоги</h2>
<p>Я считаю, если инструмент дает определенные возможности, это не значит что их стоит использовать везде где попало. Допустим не стоит создавать демона на базе php, или скажем систему которая будет ориентирована на работу в асинхронном режиме - php просто не создан для этого. Каждой задаче нужен свой инструмент.<br />
В итоге получается что php не считают серьезной платформой по следующим причинам:</p>
<ol>
<li>Огромному количеству г*внокода. Дело он свое делает, но поддерживать его тяжело.</li>
<li>Огромному количеству php программистов, которые генерировали этот г*код.</li>
</ol>
