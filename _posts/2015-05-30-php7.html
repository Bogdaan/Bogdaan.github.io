---
layout: post
status: publish
published: true
title: php7 изменения и производительность

date: '2015-05-30 15:00:12 +0300'


categories:
- backend
tags:
- web
- php
- php7
---
<p>
    Дата выхода php-7.0 все ближе и ближе. Планируемые даты релизов выглядят
    следующим образом:
</p>
<ul>
    <li>15 марта 2015 - заморозка функционала</li>
    <li>11-15 июня 2015 - выход php-7.0-rc</li>
    <li>15 октября 2015 - выход php-7.0</li>
</ul>
<p>
    Рассмотрим что будет из себя будет представлять новый релиз, и стоит ли
    переходить на php7 в будущем.
</p>

<h2>Изменения в ядре php7 (zend engine 3, phpng)</h2>
<p>
    Как многие уже знают, самые значительные изменения были проведены в ядре
    php. Начиная с php-5.0, с каждым релизом, велись работы по улучшению
    производительности как самого ядра так и OPCache. И производительность
    действительно улучшалась как в синтетических тестах так и в реальных приложениях.
    Но к версии 5.5 стало ясно что "узкое место" в плане производительности -
    это система выделения и освобождения памяти (более подробно об этом можно
    почитать на php internals). Потому было принято решение переработать
    типизацию данных, для того чтобы найти оптимальный способ выделения памяти.
    В течении около пяти месяцев велась работа по рефакторингу и изменению
    ядра Zend Engine 2.x.
</p>
<p>
    Результаты работы получили кодовое имя <a href="https://wiki.php.net/phpng" target="_blank">phpng</a>,
    так же известном как "Zend Engine 3". Так как система типизации была
    изменена - почти все расширения (такие как mysql, ereg и другие) потребовали
    значительной переработки. Многие из них уже совместимы с phpng, но не все.
</p>
<p>
    Следует учесть, что новое ядро в первую очередь было нацелено на улучшение
    производительности (и управлением памятью) у "реальных приложений" а не
    синтетических тестов. И судя по <a href="https://docs.google.com/spreadsheets/d/1qW0avj2eRvPVxj_5V4BBNrOP1ULK7AaXTFsxcffFxT8/edit#gid=1334306309" target="_blank">результатам тестов</a>
    - производительность увеличилась значительно.
</p>
<p>Из других преимуществ ядра можно отметить следующее:</p>
<ul>
    <li>полная поддержка 32bit/64bit платформ</li>
    <li>новый tread-safe механизм</li>
    <li>новый менеджер памяти</li>
    <li>отличная кодовая база для таких вещей как JIT</li>
</ul>

<p>Недостатки, или следствия изменений:</p>
<ul>
    <li>размер типов теперь зависит от целевой платформы</li>
</ul>
<p>
    В данном релизе внесены значительные изменения в конструкций языка и расширения.
    Рассмотрим их по отдельности.
</p>

<h2>Изменения в расширениях</h2>
<p>Все расширения были переработаны с учетом новой типизации, но изменения также коснулись и функций.</p>
<p>Итак, наиболее явные изменения:</p>
<ul>
    <li>Работа с регулярными выражениями (ereg):
        <ul>
            <li>удалены все функции ereg_* (вместо них необходимо использовать preg_*)</li>
        </ul>
    </li>
    <li>Работа с mysql (mysql):
        <ul>
            <li>удалены все функции mysql_* (необходимо использовать mysqli_* или PDO)</li>
        </ul>
    </li>
    <li>Множество удаленных функций в расширениях:
        <ul>
            <li>Date</li>
            <li>Curl</li>
            <li>Mcrypt</li>
            <li>Openssl</li>
            <li>json</li>
            <li>dba</li>
            <li>... список можно продолжить</li>
        </ul>
    </li>
    <li>Удалена поддержка следующих SAPI (считаются устаревшими):
        <ul>
            <li>apache1</li>
            <li>isapi</li>
            <li>toxen</li>
        </ul>
    </li>
</ul>

<h2>Новые конструкции и изменения языка</h2>
<p>
    В конструкции языка внесено множество изменений как уровня логики так и
    простых упрощений. Если говорить прямо, то компилятор php был полностью
    переписан и на данный момент использует AST для компиляции.
</p>

<p>Наиболее очевидные изменения, того что "добавлено":</p>
<ul>
    <li>возможность обработки исключения, вместо фатальной ошибки</li>
    <li>новые операторы сравнения ( <=>, ?? и другие)</li>
    <li>анонимные классы</li>
    <li>указание типа возвращаемого значения (return type declaration)</li>
    <li>группировка для оператора use</li>
    <li>работа с замыканиями (closure)</li>
    <li>скалярные типы аргументов функции (scalar type hints)</li>
    <li>опционально доступный "строгий режим" работы с типами (stitict mode)</li>
    <li>изменена трактовка переменных и выражений</li>
    <li>улучшена работа с генераторами ( ключевое слово yield from и другие изменения )</li>
    <li>конструктор класса в стиле php4 (когда имя класса совпадает с именем метод) теперь генерирует E_DEPRECATED и будет удален в php8</li>
    <li>изменено поведение побитовых операторов <<, >>  и других</li>
    <li>изменено поведение функций funct_get_args и funct_get_arg</li>
    <li>функция языка unserialize принимает дополнительный аргумент</li>
    <li>функция языка list изменила поведение</li>
    <li>изменено поведение цикла foreach (например в работе с внутренним итератором)</li>
    <li>новый синтаксис unicode последовательностей</li>
</ul>

<p>То что будет "удалено" и более не поддерживается:</p>
<ul>
    <li>удалена поддержка скрипт. тега в стиле ASP (то есть <% )</li>
    <li>удалены функции call_user_method и call_user_method_array</li>
    <li>удалена переменная $HTTP_RAW_POST_DATA  (необходимо использовать потоки)</li>
</ul>
<p>Рассмотрим некоторые нововведения подробней.</p>

<h3>Новые операторы</h3>
<p>
    Оператор <strong>use</strong> стал немного умней, теперь допускается
    конструкция с несколькими пространствами имен, к примеру:
</p>
{% highlight php %}
<?php

// было
use Hcbogdan\Blog\Post;
use Hcbogdan\Blog\Tag;
use Hcbogdan\Blog\Comment;

// стало возможным в php7
use Hcbogdan\Blog\{
  Post,
  Tag,
  Comment,
};
{% endhighlight %}

<p>
    Добавлен оператор сравнения с null  "<b>??</b>".
    Он позволяет в некоторых случаях сделать код более читабельней, к примеру:
</p>
{% highlight php %}
<?php
$foo = null;
$bar = $foo ?? 'FOO NOT SET'; // <---- FOO NOT SET
{% endhighlight %}

<p>
    Добавлен оператор комбинированного сравнения "<strong><=></strong>"
    (T_SPACESHIP). Его суть заключается в следующем:
</p>
<ul>
    <li>возвращает 0, если оба операнда равны</li>
    <li>возвращает -1, если левый больше правого</li>
    <li>возвращает 1, если правый больше левого</li>
</ul>
{% highlight php %}
<?php

// было на php5.x
function customOrder($a, $b) {
  return ($a < $b)? -1: (($a>$b) ?1 :0);
}

// стало возможным в php7
function customOrderNG($a, $b) {
  return $a <=> $b;
}
{% endhighlight %}

<h3>Исключения (exception) на замену фатальным ошибкам (fatal error)</h3>
<p>
    Отличная возможность отловить и обработать ошибочные ситуации, без краха
    логики уровня приложения.<br />
    Иерархия исключений, для обработки такого рода ошибок, выглядит
    следующим образом:
</p>
<ol>
    <li>BaseException
        <ol>
            <li>ParseException</li>
            <li>EngineException
                <ol>
                    <li>TypeException</li>
                </ol>
            </li>
            <li>Exception
                <ol>
                    <li>ErrorException</li>
                    <li>RuntimeException</li>
                </ol>
            </li>
        </ol>
    </li>
</ol>
<p>Существует возможность обрабатывать такие случаи:</p>
{% highlight php %}
<?php
try {
  ololo();
} catch(EngineException $e) {
  echo 'Ура - теперь мы можем отловить это';
}
{% endhighlight %}

<h3>Указание типа возвращаемого значения (return type declaration)</h3>
<p>
    Функции могут декларировать явно тип возвращаемого значения в прототипе
    (с помощью языковой конструкции). В случае если возвращаемое значение не
    соответствует заявленному во время выполнения - происходит FatalError.
</p>
{% highlight php %}
<?php
function ololo():int {
  return [];
}

ololo(); // <------- FATAL ERROR
{% endhighlight %}

<p>Также можно отметить, что:</p>
<ol>
    <li>такие типы как "resource" и "null" не поддерживаются</li>
    <li>в случае не совпадения типов - php пытается их привести, и только в случае неудачи происходит FatalError</li>
</ol>


<h3>Скалярные типы аргументов функции (scalar type hints)</h3>
<p>
    Данная возможность позволяет указать в прототипе функции
    тип <strong>int</strong>, <strong>bool</strong>, <strong>string</strong>
    и другие. Тип <strong>null</strong> и <strong>resource</strong> 
    не поддерживаются.
</p>
{% highlight php %}
<?php
function ololo(int $a, bool $b){ }
{% endhighlight %}

<p>
    Если во время выполнения подобной функции передается не соответствующая 
    типу переменная, компилятор пытается ее преобразовать, и в случае если это
    не возможно - происходит FatalError.
</p>

<h3>"строгий режим" работы с типами (stitict mode)</h3>
<p>
    Интерпретатор позволяет регулировать "строгость" соответствия типов данных
    с помощью директивы <strong>declare(strict_types=1)</strong>. Данная
    директива позволяет включать или выключать строгий режим типов.<br />
    Есть несколько особенностей ее использования:
</p>
<ol>
    <li>директива declare - обязана быть первым оператором в файле.</li>
    <li>при включении "строгого режима" ( в начале файла есть оператор declare(strict_types=1) ) - данный режим включается только у того файла где есть эта директива</li>
</ol>
<p>Пример работы в обычном режиме:</p>
{% highlight php %}
<?php
function ololo(int $a){ }
ololo( '11' );
// выполнено без ошибок
{% endhighlight %}

<p>Пример работы в "строгом режиме":</p>
{% highlight php %}
<?php
declare(strict_types=1);
function ololo(int $a){ }
ololo( '11' ); // <----- FATAL ERROR
{% endhighlight %}


<h3>Анонимные классы</h3>
<p>Анонимные классы похожи на аналогичные в других языках и на существующие в php5 анонимные функции.</p>
{% highlight php %}
<?php
var_dump( new ololo(){ } );  // <---- все в порядке{% endhighlight %}

<h3>Изменения в интерпретации переменных</h3>
<p>В новой версии интерпретация переменный стала следовать семантике left-to-right. Сравним некоторые случаи.</p>
<p>PHP5:</p>
{% highlight php %}
<?php
${$a['b']['c']}
$a->{$b['c']}
$a->{$b['c']}()
Ololo::{$b['c']}()
{% endhighlight %}

<p>PHP7:</p>
{% highlight php %}
<?php
($$a)['b']['c']
($a->$b)['c']
($a->$b)['c']()
(Ololo::$a)['b']()
{% endhighlight %}


<h3>Изменения в некоторых языковых конструкциях</h3>
<p>Изменено поведение <strong>list()</strong>, и именно:</p>
<ul>
    <li>добавлена возможность распаковки объектов с ArrayAccess</li>
    <li>убрана возможность распаковки строки</li>
</ul>

<p>Из приведения типов убрано привидение типов из строки "0xXXX" в число.</p>
{% highlight php %}
<?php
var_dump( '0x123' == '291' );
// php5: true
// php7: false
{% endhighlight %}

<p>Убрана возможность повторной декларации переменных в прототипе функции:</p>
{% highlight php %}
<?php
function ololo($a, $a){ } // <-------- FATAL ERROR
{% endhighlight %}

<p>Для именования классов, интерфейсов и примесей теперь нельзя использовать имена зарезервированных типов:</p>
{% highlight php %}
<?php
class String { } // <---------- FATAL ERROR
{% endhighlight %}

<p>
    Изменено поведение побитовых операторов. Сдвиг <strong>int</strong> на
    количество битов большее разрядности <strong>int</strong> всегда будет возвращать 0.
</p>
{% highlight php %}
<?php
var_dump( 1 << 64 );
// php5: 1
// php7: 0
{% endhighlight %}

<p>
    Побитовый сдвиг на отрицательное число будет возвращать <strong>false</strong>
    и генерировать предупреждение.
</p>
{% highlight php %}
<?php
var_dump( 1 >> -1 );
// php5: 0
// php7: false
{% endhighlight %}


<h2>Выводы</h2>
<p>
    Проделанная разработчиками работа над php7 действительно огромная. Язык
    начинает приобретать новый, более изящный вид. Да, в этом релизе все еще
    существует оператор "goto" и наборы функций вроде "array_*", как и много
    других спорных моментов. Тем не менее, даже с учетом этого, прогресс есть :).
</p>
<p>
    Как и другие major релизы, php7 ломает не мало зависимостей, но с другой
    стороны дает более совершенный инструмент для разработчика. По результатам
    тестов (синтетических и на реальных системах) мы получаем (имеются ввиду
    билд с HHVM):
</p>
<ol>
    <li><span style="line-height: 1.6471;">прирост производительности в 2 раза (примерно) </span></li>
    <li>потребление памяти уменьшено на ~ 40% (почти в два раза)</li>
</ol>
